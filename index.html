let lastProcessedCommand = '';
let lastCommandTime = 0;
let interimCommand = '';

recognition.onresult = function(event) {
    const result = event.results[event.results.length - 1];
    const transcript = result[0].transcript.trim().toLowerCase();
    
    if (result.isFinal) {
        processVoiceCommand(transcript);
    } else {
        interimCommand = transcript;
        if (interimCommand.length > 3 && interimCommand !== lastProcessedCommand) {
            processVoiceCommand(interimCommand);
        }
    }
};

function processVoiceCommand(command) {
    console.log("인식된 음성:", command);
    
    const currentTime = Date.now();
    if (command === lastProcessedCommand && currentTime - lastCommandTime < 300) {
        return; // 0.3초 이내에 같은 명령이 반복되면 무시
    }
    
    const directionMap = {
        '위': '위', '위로': '위', '앞': '위', '앞으로': '위',
        '아래': '아래', '아래로': '아래', '뒤': '아래', '뒤로': '아래',
        '왼': '왼쪽', '왼쪽': '왼쪽', '왼쪽으로': '왼쪽',
        '오른': '오른쪽', '오른쪽': '오른쪽', '오른쪽으로': '오른쪽'
    };
    
    const numberMap = {
        '한': 1, '하나': 1, '두': 2, '둘': 2, '세': 3, '셋': 3, '네': 4, '넷': 4, '다섯': 5,
        '여섯': 6, '일곱': 7, '여덟': 8, '아홉': 9, '열': 10
    };

    const regex = /((위|아래|왼|오른|앞|뒤)(?:으?로)?)\s*(한|하나|두|둘|세|셋|네|넷|다섯|여섯|일곱|여덟|아홉|열|\d+)?(?:\s*칸)?/;
    const matches = command.match(regex);

    if (matches) {
        const direction = directionMap[matches[1]] || matches[1];
        let steps = 1;
        if (matches[3]) {
            steps = numberMap[matches[3]] || parseInt(matches[3]) || 1;
        }
        movePlayer(direction, steps);
        addCommandToHistory(command);
        
        lastProcessedCommand = command;
        lastCommandTime = currentTime;
    }
}

function movePlayer(direction, steps) {
    if (!gameStarted) return;
    const oldPosition = {...playerPosition};
    switch (direction) {
        case '위':
            playerPosition.y = Math.max(1, playerPosition.y - steps);
            break;
        case '아래':
            playerPosition.y = Math.min(10, playerPosition.y + steps);
            break;
        case '왼쪽':
            playerPosition.x = Math.max(1, playerPosition.x - steps);
            break;
        case '오른쪽':
            playerPosition.x = Math.min(10, playerPosition.x + steps);
            break;
    }
    requestAnimationFrame(() => {
        clearPlayer();
        renderPlayer();
        drawLine(oldPosition, playerPosition);
        checkCollision();
    });
}
